# Вопросы CoreJS

## ТИПЫ ДАННЫХ:

- [Перечислите все типы данных](topics/types/types.md)
- [Как узнать какой тип данных перед нами?](topics/types/typeof.md#typeof)
- [Почему typeof null === 'object'?](topics/types/typeof.md#typeofnull)
- [Почему typeof function() {} === 'function'?](topics/types/typeof.md#typeoffunc)
- [В чем их разница между null и undefined?](topics/types/typeof.md#null-undefined)
- [Как создать объект? (три способа)](topics/types/typeof.md#obj)
- [Что такое NaN? typeof NaN.](topics/types/typeofNaN.md#typeofnan)
- [NaN === NaN ? Почему?](topics/types/typeofNaN.md#naneqvelnan)
- [Тогда как узнать что перед нами NaN?](topics/types/typeofNaN.md#isnan)
- [Что такое Infinity?](topics/types/typeofInfinity.md#typeofinfinity)
- [isFinite() что это за функция?](topics/types/typeofInfinity.md#isfinite)
- [0.1 + 0.2 === 0.3 ? Почему?](topics/types/number.md#loss-of-accuracy)
- [Числовые методы приведения строки в число.](topics/types/number.md#number-methods)
- [Можем ли к числу применять .toString(). Какая у этого метода особенность?](topics/types/number.md#number-tostring)
- [Что такое Math? Приведите примеры.](topics/types/number.md#math-obj)
- [Mетоды строк. Как получить подстроку.](topics/types/string.md#string-methods)
- [Что будет в консоли и почему:](topics/types/string.md#immutability)
  ```JS
  let str = "Привет!"
  str[0]= "п"
  console.log(str)
  ```
- [Что такое шаблонные строки? Перечисли особенности.](topics/types/string.md#template)
- [Что такое конкатенация?](topics/types/string.md#concatenation)
- [Что такое регулярные выражения? Метод для работы с ними. Приведите примеры.](topics/types/string.md#regex)
  
#### ПРИВЕДЕНИЕ ТИПОВ ДАННЫХ

- [Какие типы данных можно привести? Как? Явно и неявно.](topics/types/dataTypeReduction.md)
   
## ОПЕРАТОРЫ:

- [Перечислите операторы сравнения](topics/operators/operators.md#compare)
- [Разница между `==` и `===`](topics/operators/operators.md#strict-and-lax)
- [Перечислите логические операторы](topics/operators/operators.md#logical)   
- [Что такое оператор нулевого слияния?](topics/operators/operators.md#zero-merge)
- [В чем разница ?? с логическим ИЛИ](topics/operators/operators.md#merge-logical)
- [Перечислите falsy values](topics/operators/operators.md#falsy-values)
- [Важные моменты при работе с операторами сравнения:](topics/operators/operators.md#important)
- [К чему приводятся null и undefined при использовании математических операторов и операторов сравнения.](topics/operators/operators.md#null-undefined)
- [Swich case конструкция, что это для чего что заменяет?](topics/operators/swichCase.md#swich-case)
- [Обязателен ли default? A break?](topics/operators/swichCase.md#default-break) 
- [Что такое тернарный оператор? Почему он называется тернарный?](topics/operators/otherOperators.md#ternary) 
- [Может ли мы создавать цепочку из тернарных операторов?](topics/operators/otherOperators.md#ternary-chain) 
- [Что такое оператор запятая?](topics/operators/otherOperators.md#comma) 
- [Что такое оператор расширения (разворота)? spread-оператор](topics/operators/otherOperators.md#spread) 
- [JS операторы spread vs rest](topics/operators/otherOperators.md#spread-vs-rest) 

## ПЕРЕМЕННЫЕ, ХОИСТИНГ
- [Как можно объявить переменную?](topics/variables/variables.md#var-let-const)
- [Что такое переменная?](topics/variables/variables.md#variable)
- [Разница между let, var и const](topics/variables/variables.md#difference)
- [Что такое хоистинг?](topics/variables/variables.md#hoisting)
- [Какие функции всплывают?](topics/variables/variables.md#func-hoisting)
- [Что будет если](topics/variables/variables.md#var-a)
  ```JS
	 console.log(a)
	 var a = 5;
	```
- [А если var заменить на let что измениться?](topics/variables/variables.md#let-a)
- [Что такое временная мертвая зона и зачем она нужна?](topics/variables/variables.md#tdz)
- [Почему var обладают хоистингом](topics/variables/variables.md#var-hoisting)
- [Что такое полифиллы. Приведи пример.](topics/variables/variables.md#polyfill)

## ФУНКЦИИ:

- [Что такое функциональное программирование](topics/functions/functions.md#func-prog)
- [Какие виды функций вы знаете. Какие различия?](topics/functions/functions.md#functions)
- [Какие особенности у стрелочной функции?](topics/functions/functions.md#arrow-func)
- [Что такое callback функция?](topics/functions/functions.md#callback)
- [Что такое функция высшего порядка?](topics/functions/functions.md#higher-order)
- [Что такое чистая функция?](topics/functions/functions.md#clean-func)
- [Что такое iife? Для чего она нужна?](topics/functions/functions.md#iife)
- [Что такое функция конструктор?](topics/functions/functions.md#constructor)
- [Что такое замыкание?](topics/functions/functions.md#closure)
- [Что такое new?](topics/functions/functions.md#new)
- [Что такое this?](topics/functions/functions.md#this)
- [Можем ли мы привязаться this к функции? Какие методы?](topics/functions/functions.md#this-func)
- [Особенности bind.](topics/functions/functions.md#bind)

## OOP
- [Что такое OOP?](topics/OOP/OOP.md#oop)
- [Что такое инкапсуляция?](topics/OOP/OOP.md#encapsulation)
- [Что такое наследование?](topics/OOP/OOP.md#inheritance)
- [Что такое полиморфизм?](topics/OOP/OOP.md#polymorphism)
- [Что такое ассоциация?](topics/OOP/OOP.md#association)
- [Что такое композиция?](topics/OOP/OOP.md#composition)
- [Что такое агрегация?](topics/OOP/OOP.md#aggregation)
- [Что такое абстрактный класс?](topics/OOP/OOP.md#abstract-class)
- [Что такое интерфейс?](topics/OOP/OOP.md#interface)
- [Что такое абстрактный метод?](topics/OOP/OOP.md#abstract-method)
- [Что такое статический метод?](topics/OOP/OOP.md#static-method)
- [Что такое статическое свойство?](topics/OOP/OOP.md#static-prop)
- [Что такое инстанс и инстанцирование?](topics/OOP/OOP.md#instance)
- [Что такое декоратор?](topics/OOP/OOP.md#decorator)
- [Что такое декоратор класса?](topics/OOP/OOP.md#class-decorator)
- [Что такое декоратор метода?](topics/OOP/OOP.md#method-decorator)
- [Что такое декоратор свойства?](topics/OOP/OOP.md#prop-decorator)
- [Что такое декоратор параметра?](topics/OOP/OOP.md#param-decorator)
- [Что такое декоратор геттера и сеттера?](topics/OOP/OOP.md#get-set-decorator)
- [Что такое декоратор функции?](topics/OOP/OOP.md#func-decorator)
  
## ОБЪЕКТЫ.

- [Создать объект через Object.create.](topics/objects/objects.md#obj-create)
- [Дескрипторы свойств объекта.](topics/objects/objects.md#descriptors)
- [Как копировать объект. Глубоко и нет. Нюансы JSON.stringify.](topics/objects/objects.md#copy-obj)
- [Перечисли встроенные методы объекта, для получения ключей, значений, и ещё один похожий метод.](topics/objects/objects.md#keys-values)
- [Что такое Map и Set? Чем Map отличается от объекта.](topics/objects/objects.md#map-set)
- [Что делает метод Object.is?](topics/objects/objects.md#obj-is)
- [Что делают методы Object.freeze() и Object.seal()?](topics/objects/objects.md#freeze)

## МАССИВЫ.

- что такое массив, как создать, несколько способов, как копировать.
- Как копиро вать честь массива.
- Как сгладить вложенный массив
- разница map и forEach
- reduce что делает, что принимает вторым аргументом
- filter что делает
- какие методы изменяют исходный массив
- можем ли мы изменять массив и объект после объявления через co  nst. Почему?

## ЦИКЛЫ

- перечислите все циклы `(for, for...in, for...of, while, do...while)`
  
  for...in для чего: предназначен для перебора всех свойств объекта.   
  for...of для чего: предназначен для итерации по элементам итерируемых объектов,   
таких как массивы, строки, наборы (Set), карты (Map), и др.   

- можно ли применить for...in для массива. Что будет?

Да, цикл for...in можно использовать для итерации по массиву,
но он не гарантирует порядок итерации по элементам массива.
Он не будет возвращать индексы в нужном порядке и вернёт все перечисляемые свойства, включая имеющие не целочисленные имена и наследуемые.

- можно ли применить for...of или while для объекта? Что будет?

Циклы for...of и while не могут быть прямо применены к объекту, так как они
предназначены для итерации по итерируемым коллекциям, таким как массивы или строки.
Объекты в JavaScript не являются итерируемыми по умолчанию.
Есть способы итерироваться по свойствам объекта, но не непосредственно по самому объекту.

- цикл do...while что делает?

Цикл do...while выполняет блок кода, заключенный внутри него, минимум один раз,
а затем проверяет условие. Если условие истинно (true), цикл повторяется и выполняет блок кода снова. Цикл продолжается до тех пор, пока условие не станет ложным (false).

- break и continue: используются для управления выполнением цикла и
перехода к следующей итерации или выхода из цикла.

1. Кога break встречается внутри цикла, выполнение цикла немедленно прерывается, и управление передается за пределы цикла. Это позволяет выйти из цикла досрочно, не дожидаясь завершения всех итераций. break часто используется для остановки цикла на основе определенного условия.
2. Когда continue встречается внутри цикла, оставшаяся часть текущей итерации пропускается, и управление переходит к следующей итерации. Это позволяет пропустить некоторые шаги итерации в цикле на основе определенного условия, но продолжить выполнение остальной части цикла.

## БРAУЗЕР

- [Что такое DOM?](topics/browser/browser.md#dom)
- [Что такое document?](topics/browser/browser.md#document)
- [Что такое BOM?](topics/browser/browser.md#bom)
- [Что такое CSSOM?](topics/browser/browser.md#cssom)
- [Поиск элементов в DOM](topics/browser/browser.md#dom-serch)
- [Живые и неживые коллекции что это?](topics/browser/browser.md#collections)
- [Браузерные события](topics/browser/browser.md#events)
- [Фазы события](topics/browser/browser.md#phases)
- [Обработчик событий, как повесить, как убрать. Какой нюанс, если мы хотим удалить обработчик](topics/browser/browser.md#event-listeners)
- [Еvent.preventDefault() что это что делает](topics/browser/browser.md#prevent-default)
- [Как предотвратить распространение события](topics/browser/browser.md#stop-propagandation)
- [Что такое делегирования событий](topics/browser/browser.md#delegate)

## АСИНХРОННОСТЬ

- что такое синхронный код -
  это значит, что код выполняется синхронно с основным потоком программы. Выполнение функций происходит в том же месте, где они были вызваны, и в тот момент, когда происходит вызов.
  Например:

  ```JS
  const syncFunc = () => 1 + 1;

  const main = () => {
  	const result = syncFunc();
  	console.log(result);
  };

  main();
  ```

В примере выше функция syncFunc — это синхронная, то есть обычная функция. Функция main() представляет собой основную функцию программы, в ней вызывается функция syncFunc(). Благодаря тому, что функция syncFunc синхронная, то работа функции main будет длиться не меньше, чем работа функции syncFunc. Если функция syncFunc будет выполняться 3 секунды, то и main будет выполняться не меньше 3 секунд, что логично, ведь внутри main код ждет, пока выполнится syncFunc. Если выполнение syncFunc увеличится, например, на 2 секунды, то и работа main увеличится на 2 секунды. То есть время работы функций syncFunc и main синхронно.

- что такое асинхронный код -

  это когда вызов функции не означает, что она отработает прямо здесь и сейчас. Более того, мы не знаем, когда она отработает. В современном JavaScript приложении встречается много задач, которые выполняются асинхронно (обращение к серверу, анимация, работа с файловой системой, геолокация).

- что такое event loop - встроенный механизм, который обрабатывает выполнение нескольких фрагментов программы,
  осуществляет контроль стека вызовов и очереди обратных вызовов. Если стек вызовов пуст, цикл событий возьмет первое событие из очереди и отправит его в стек вызовов, который его запустит.
  ![Alt text](image.png)
- что такое коллбеки - любые функции, которые передаются как аргументы другим функциям, называются callback-функциями. Коллбек - функция, предназначенная для отложенного выполнения. Проще говоря, она должна быть выполнена после завершения работы другой функции.
- что такое промисы - это часть отдельного API, специально сделанного для работы с асинхронным кодом. Они позволяют описывать код, который нужно выполнить не сразу, а только когда произойдёт какое-то событие.
  Чтобы «научить» движок обрабатывать запрос, конструктору промисов передают на вход функцию. Она в свою очередь тоже принимает на вход два колбэка: resolve и reject. Эти колбэки переводят промис в статус «исполнен» или «отклонён».

  ```JS
  const newPromise = new Promise(function (resolve, reject) {
    /* Будем определять, обработан запрос
    или нет, случайным образом */
    const rand = Math.random() > 0.5 ? true : false;

    if (rand) {
        resolve('Запрос обработан успешно');
    } else {
        reject('Запрос отклонён');
    }
  	});
  ```

Код функции, переданной конструктору Promise исполняется немедленно. Как только вы откроете файл, движок запустит код промиса: создаст переменную rand, присвоит ей true или false. Дальше в зависимости от значения переменной rand движок переведёт наш промис в статус «исполнен» или «отклонён».
Дальше нужно прописать логику: что делать движку, если промис будет обработан, и что — если отклонён. Для этого есть методы then, catch и finally. Первый выполнится, если промис был исполнен, второй — если отклонён, а третий — в любом случае. Первые два метода — then и catch — принимают на вход функцию с одним аргументом. Этот аргумент — то самое значение, с которым мы вызывали resolve и reject при создании промиса:

```JS
newPromise
    .then(function (value) { // Если промис был обработан

        /* Параметр value хранит значение, переданное методу
        resolve при создании промиса, то есть строку
        "Запрос обработан успешно" */

        console.log(value);
    })
    .catch(function (value) { // Если промис был отклонён

        /* Здесь параметр value будет хранить то значение,
        которое было передано методу reject, то есть строку
        "Запрос отклонён" */

        console.log(value + ', нам жаль :(');
    })
    .finally(function () { // В любом случае
        console.log('Как бы там ни было — запрос мы в глаза видели');
    });
```

- что такое async await - синтаксис для работы с промисами. Ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт завершившийся успешно промис. Ключевое слово – await можно использовать только внутри async-функций.

```JS
async function f() {

let promise = new Promise((resolve, reject) => {
setTimeout(() => resolve("готово!"), 1000)
});

let result = await promise; // будет ждать, пока промис не выполнится (\*)

alert(result); // "готово!"
}

f();
```

В данном примере выполнение функции остановится на строке (\*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.

- что такое микро и макро задачи.

Микро и макрозадачи в событийном цикле - бесконечном цикле, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Общий алгоритм движка:

1 Пока есть задачи:
выполнить их, начиная с самой старой

2 Бездействовать до появления новой задачи, а затем перейти к пункту 1

Это формализация того, что мы наблюдаем, просматривая веб-страницу. Движок JavaScript большую часть времени ничего не делает и работает, только если требуется исполнить скрипт/обработчик или обработать событие.

Примеры задач:

Когда загружается внешний скрипт `<script src="...">`, то задача – это выполнение этого скрипта.
Когда пользователь двигает мышь, задача – сгенерировать событие mousemove и выполнить его обработчики.
Когда истечёт таймер, установленный с помощью setTimeout(func, ...), задача – это выполнение функции func
И так далее.
Задачи поступают на выполнение – движок выполняет их – затем ожидает новые задачи (во время ожидания практически не нагружая процессор компьютера)

Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.

Очередь, которую формируют такие задачи, называют <b>«очередью макрозадач»</b>.

Пример: разбиение «тяжёлой» задачи.

Допустим, у нас есть задача, требующая значительных ресурсов процессора.

Например, подсветка синтаксиса (используется для выделения цветом участков кода на этой странице) – довольно процессороёмкая задача. Для подсветки кода надо выполнить синтаксический анализ, создать много элементов для цветового выделения, добавить их в документ – для большого текста это требует значительных ресурсов.

Пока движок занят подсветкой синтаксиса, он не может делать ничего, связанного с DOM, не может обрабатывать пользовательские события и т.д. Возможно даже «подвисание» браузера, что совершенно неприемлемо.

Мы можем избежать этого, разбив задачу на части. Сделать подсветку для первых 100 строк, затем запланировать setTimeout (с нулевой задержкой) для разметки следующих 100 строк и т.д.

Чтобы продемонстрировать такой подход, давайте будем использовать для простоты функцию, которая считает от 1 до 1000000000.

Если вы запустите код ниже, движок «зависнет» на некоторое время. Для серверного JS это будет явно заметно, а если вы будете выполнять этот код в браузере, то попробуйте понажимать другие кнопки на странице – вы заметите, что никакие другие события не обрабатываются до завершения функции счёта.

```JS
let i = 0;

let start = Date.now();

function count() {

  // делаем тяжёлую работу
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Done in " + (Date.now() - start) + 'ms');
}

count();

```

Браузер может показать сообщение «скрипт выполняется слишком долго».

Давайте разобьём задачу на части, воспользовавшись вложенным setTimeout и перенесём планирование очередного вызова в начало count():

```JS
let i = 0;

let start = Date.now();

function count() {

  // перенесём планирование очередного вызова в начало
  if (i < 1e9 - 1e6) {
    setTimeout(count); // запланировать новый вызов
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();
```

этот код требует значительно меньше времени.

Мы разбили ресурсоёмкую задачу на части – теперь она не блокирует пользовательский интерфейс, причём почти без потерь в общем времени выполнения.

![Alt text](table-tasks.png)
И микрозадачи, и макрозадачи являются асинхронными задачами, но они будут входить в две разные асинхронные очереди, и приоритет очереди микрозадач выше приоритета макрозадачи.

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

Например:

```JS
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");

```

Какой здесь будет порядок?

code появляется первым, т.к. это обычный синхронный вызов.
promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
timeout появляется последним, потому что это макрозадача.
Более подробное изображение событийного цикла выглядит так:

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.

Это важно, так как гарантирует, что общее окружение остаётся одним и тем же между микрозадачами – не изменены координаты мыши, не получены новые данные по сети и т.п.

Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, то можем запланировать это через queueMicrotask.

Вот пример с индикатором выполнения, похожий на предыдущий, но в этот раз использована функция queueMicrotask вместо setTimeout. Обратите внимание – отрисовка страницы происходит только в самом конце. Как и в случае обычного синхронного кода.

```JS
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // делаем часть крупной задачи (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      queueMicrotask(count);
    }

  }

  count();
</script>
```

Итого
Более подробный алгоритм событийного цикла (хоть и упрощённый в сравнении со спецификацией):

1 Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).

2 Исполнить все микрозадачи:
Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу

3 Отрисовать изменения страницы, если они есть.

4 Если очередь макрозадач пуста – подождать, пока появится макрозадача.

5 Перейти к шагу 1.
Чтобы добавить в очередь новую макрозадачу:

Используйте setTimeout(f) с нулевой задержкой.
Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).

Для добавления в очередь новой микрозадачи:

Используйте queueMicrotask(f).
Также обработчики промисов выполняются в рамках очереди микрозадач.
События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.

Визуализация - порядок исполнения задач

![Alt text](micro-macro.gif)

## ОБЩЕЕ

- что такое стек вызовов
- что такое очередь задач
- что такое мемоизация
- что такое рекурсия
- что такое чистая функция
- что такое побочный эффект
- что такое мутация
- что такое иммутабельность
- что такое декларативный код
- что такое императивный код
- что такое SOLID, DRY, KISS, YAGNI
- что такое TDD
- что такое BDD
- что такое DDD
- что такое Feature sliced design
- что такое MVC
- что такое MVVM
- что такое MVP
- что такое SPA
- что такое SSR
- что такое CSR
- что такое PWA
- что такое SSR
- что такое антипаттерны
- что такое рефакторинг
- что такое абстракция

## Ссылки

- дом https://docs.google.com/presentation/d/1rBIdCmdt_FmbynznNmzhYvvSJ3jGhnLV/edit?pli=1#slide=id.p1
- типы данных, переменные: https://docs.google.com/presentation/d/1umua1fqaY87LzaYetfd8aTfOaH2SuApo/edit#slide=id.p2
- еще делились, спрашивали про
  Symbol.iterator https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator
