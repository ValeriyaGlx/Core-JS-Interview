# Что такое функциональное программирование
 **Функциональное программирование** (Functional Programming) - это парадигма программирования, в которой основной строительный блок программы представляет собой функцию.    
 В функциональном программировании функции рассматриваются как математические объекты, которые принимают входные данные (аргументы) и возвращают результат (значение) без изменения состояния программы или окружения.

# Какие виды функций вы знаете. Какие различия.
- ##### Функции вида "function declaration statement":
  
   Обычные функции (иногда называемые именованными функциями) объявляются с использованием ключевого слова function.   
	 Они имеют имя и могут быть вызваны в любом месте кода.   
	 Могут быть использованы для выполнения определенных операций, возврата значений, работы с аргументами и т.д.   

	```javascript
		function add(a, b) {
			return a + b;
		}

		console.log(add(2, 3)); // Output: 5
	```
- ##### Функции вида "function definition expression"
  
   Анонимные функции не имеют имени и часто объявляются в месте их использования.    
   Часто используются как callback функции или передаются в функции высшего порядка.    
   Могут быть присвоены переменным или переданы аргументами другим функциям.   

  ```javascript
		const multiply = function(a, b) {
			return a * b;
		};

		console.log(multiply(2, 3)); // Output: 6
  ```
- ##### Стрелочные функции (Arrow Functions):
   Стрелочные функции - это сокращенный синтаксис для объявления функций.   
   Они используют стрелку => и заимствуют this из окружающего контекста.   
   Удобны для коротких функций, особенно в контексте асинхронного программирования.   

  ```javascript
		 const divide = (a, b) => a / b;
		 console.log(divide(6, 2)); // Output: 3
  ```

# Какие особенности у стрелочной функции

Стрелочные функции в JavaScript (также называемые "arrow functions") являются сокращенным синтаксисом для определения функций. Они были введены в ECMAScript 6 (ES6) и предоставляют несколько особенностей и различий от обычных функций. Вот некоторые из особенностей стрелочных функций:

- ###### Краткий синтаксис:
   
Стрелочные функции имеют более компактный синтаксис, который делает их более удобными для написания коротких функций.

- ###### Отсутствие собственного this:
   
Одной из основных особенностей стрелочных функций является то, что у них нет своего собственного this. Вместо этого this в стрелочных функциях заимствуется из окружающего контекста. Это означает, что this в стрелочной функции будет тем же, что и внутри контекста, в котором она была объявлена.

- ###### Отсутствие привязки arguments:
   
В стрелочных функциях также отсутствует свойство arguments, которое доступно в обычных функциях. Вместо этого вы можете использовать спред-оператор ...args, чтобы получить аргументы функции.


# Что такое callback функция

Callback функция (или просто "callback") - это функция, которая передается в качестве аргумента другой функции и вызывается после завершения выполнения этой функции. Использование callback функций является одним из механизмов асинхронного программирования в JavaScript.

```JS
	// Функция, выполняющая асинхронную операцию (имитируем задержку с помощью setTimeout)
	function asyncOperation(callback) {
  		setTimeout(function() {
    	console.log("Асинхронная операция выполнена.");
    	callback(); // Вызываем callback функцию после завершения операции
  		}, 2000); // Задержка в 2 секунды
	}

	// Callback функция
	function callbackFunction() {
  		console.log("Callback функция вызвана.");
	}

	// Вызываем функцию с передачей callback функции в качестве аргумента
	asyncOperation(callbackFunction);
```

# Что такое функция высшего порядка?
#### **Функции высшего порядка (Higher-Order Functions)**:
Функции высшего порядка являются функциями, которые принимают одну или несколько функций в качестве аргументов или возвращают функции в качестве результата.
Они позволяют абстрагировать операции и повторно использовать код, делая его более гибким и удобным.

```JS
  ///doMathOperation - Функция высшего порядка
  function doMathOperation(operation, a, b) {
    return operation(a, b);
  }

  function add(a, b) {
    return a + b;
  }

  function subtract(a, b) {
    return a - b;
  }
```

# Что такое чистая функция?
#### **Чистая функция**
Это функция, которая не вызывает побочных эффектов (side effects), то есть никак не влияет на состояние внешнего мира.
Чистые функции всегда при вводе одинаковых аргументов выдают одинаковый результат. По этому свойству легко отличить чистую функцию от нечистой.

Например, **pureFn()** при вводе 10 и 20 всегда будет возвращать 15,
значит она **чистая**:

```JS
	      function pureFn(a, b) {
		      return ((a + b) * a) / b
	      }
  	    ```
		  А impureFn() **нечистая** — она будет возвращать разные значения,
	 	  потому что использует случайное число:

	    ```JS
	    function impureFn(a, b) {
		    return ((a + b) * a) / Math.random()
	    }
```
# Что такое iife? Зачем?

IIFE (Immediately Invoked Function Expression) - это паттерн программирования в JavaScript, который используется для создания и вызова функции немедленно после ее определения. Он представляет собой анонимную функцию, которая окружается скобками и сразу же вызывается.

Пример IIFE:
```JS
		(function() {
  			// Код, который будет выполнен немедленно
		})();
```
	- ##### Зачем использовать IIFE?

		- ###### Изолированная область видимости:
  			IIFE создает свою собственную область видимости, что позволяет избежать конфликтов имен переменных с другими частями кода. Переменные, объявленные внутри IIFE, ограничены областью видимости этой функции и не влияют на глобальную область видимости. Переменные и функции, определенные внутри IIFE, не могут быть доступны или изменены извне этой функции, что улучшает безопасность и предотвращает нежелательные изменения состояния.

		- ###### Защита от поднятия переменных:
  			IIFE предотвращает поднятие (hoisting) переменных в глобальную область видимости. Переменные, объявленные внутри IIFE, не будут доступны извне этой функции.

		- ###### Предотвращение конфликтов:
  			Если у вас есть несколько библиотек или фреймворков, которые могут использовать одни и те же имена функций или переменных, IIFE помогает изолировать их и предотвращает возможные конфликты.


# Что такое функция конструктор
Функция-конструктор (Constructor Function) - это специальный тип функций в JavaScript, который используется для создания и инициализации новых объектов. Они являются основой для реализации классов и объектно-ориентированного программирования в JavaScript до появления классов в ECMAScript 6.

Функция-конструктор определяет шаблон (также называемый "классом") для создания объектов с определенными свойствами и методами. При вызове функции-конструктора с оператором new, создается новый экземпляр объекта, наследующий свойства и методы из прототипа функции-конструктора.
```javascript
	function ConstructorFunction(param1, param2) {
  		this.property1 = param1;
  		this.property2 = param2;
  		this.method = function() {
  	 	 // методы объекта
  		};
	}
	const instance = new ConstructorFunction(value1, value2);
```
Функции-конструкторы позволяют создавать множество объектов с общими свойствами и методами, что делает их полезными для организации кода в объектно-ориентированном стиле. Однако с появлением классов в ECMAScript 6, классы и ключевые слова class, constructor, extends и super стали предпочтительным методом для реализации объектно-ориентированного программирования в JavaScript.

# Что такое замыкание
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. Это означает, что функция может обращаться к переменным и параметрам из родительской функции, даже если родительская функция уже завершила своё выполнение.
В JavaScript, все функции изначально являются замыканиями (кроме "new Function"), то есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [Environment], и все они могут получить доступ к внешним переменным. (Свойство [Environment] - это внутреннее свойство объекта функции в JavaScript, которое используется для хранения лексической области видимости (environment record) функции. Оно связывает функцию с её лексическим окружением, то есть с переменными, функциями и параметрами, которые были доступны в момент её создания.)



###### **Пример замыкания:**

```javascript
	function outerFunction() {
		const outerVariable = 'I am from the outer function';

		function innerFunction() {
			console.log(outerVariable); // Внутренняя функция имеет доступ к outerVariable
		}

		return innerFunction;
	}

	const closureFunc = outerFunction(); // Возвращает внутреннюю функцию

	closureFunc(); // Выводит: "I am from the outer function"
```
В этом примере **innerFunction** является замыканием, потому что она запоминает переменную **outerVariable**, которая определена в родительской функции outerFunction. Даже после того, как outerFunction выполнена и вернула **innerFunction**, **innerFunction** всё равно может получить доступ к переменной **outerVariable**, потому что у неё есть доступ к лексической области видимости родительской функции (scope chain).

# Что такое new?
В JavaScript ключевое слово new используется для создания новых экземпляров объектов, основанных на функциях-конструкторах. Когда вы используете new перед вызовом функции, она становится конструктором, и это приводит к созданию нового объекта с привязкой к этой функции.

	###### Процесс создания объекта с помощью new включает в себя следующие шаги:

	1. Создается новый пустой объект.
	2. Привязывается контекст вызова функции к этому новому объекту.
	3. Конструктор выполняется с этим контекстом (таким образом, функция может добавлять свойства и - методы к создаваемому объекту через this).
	4. Если в конструкторе явно не указано возвращаемое значение, то возвращается новый объект, созданный в первом шаге. Если конструктор явно возвращает примитивное значение, оно будет проигнорировано, и вернется созданный объект.

	```javascript
	function Person(name, age) {
  		this.name = name;
  		this.age = age;
	}

	// Создание нового экземпляра объекта "Person" с помощью new
	const person1 = new Person('Alice', 30);
	const person2 = new Person('Bob', 25);

	console.log(person1); // { name: 'Alice', age: 30 }
	console.log(person2); // { name: 'Bob', age: 25 }
	```
	Здесь Person - это функция-конструктор, которая принимает два аргумента name и age и добавляет их в создаваемый объект через ключевое слово this. При использовании new мы создаем два разных экземпляра объекта "Person" с разными значениями свойств name и age.


# Что такое this?
  В JavaScript ключевое слово this представляет ссылку на текущий контекст выполнения или объект, в котором вызывается текущий код. Значение this может изменяться в зависимости от контекста, в котором функция вызывается или метод объекта используется.
	Значение this определяется во время выполнения и зависит от следующих
	факторов:
- ###### Глобальный контекст:
  Если this используется вне любой функции или метода, то оно ссылается на  объект window (в браузере) или на объект global (в Node.js), который представляет глобальный контекст.
- ###### Функции:
  Когда this используется в обычной функции (не стрелочной функции), значение this зависит от того, как функция была вызвана:
  Если функция вызывается как метод объекта, то this ссылается на сам объект, которому принадлежит метод.
  Если функция вызывается как обычная функция (не является методом объекта), то this будет ссылаться на глобальный объект window (в браузере) или global (в Node.js) в нестрогом режиме, а в строгом режиме this будет undefined.
- ###### Методы объекта:
	Когда функция вызывается как метод объекта, значение this будет ссылаться на сам объект, к которому принадлежит метод.
- ###### Конструкторы:
	При использовании функции как конструктора с ключевым словом new, this ссылается на новый объект, созданный конструктором.

	##### Явное указание контекста:
	Вы можете явно указать значение this, используя методы call(), apply() или bind() на функции. Это позволяет установить this вручную, независимо от контекста вызова.

# Можем ли мы привязаться this к функции? Какие методы?
    В JavaScript мы можем явно привязать значение this к функции, используя следующие методы:
	- ###### Function.prototype.bind():
  		Метод bind() создает новую функцию с тем же телом функции, что и исходная функция, но с явно указанным значением this. Метод bind() не вызывает функцию немедленно, а возвращает новую функцию с привязанным контекстом this.
		```JS

		const obj = {
		    name: 'Alice',
		    sayHi: function() {
		        console.log('Hello, ' + this.name);
		    }
		};

		const boundFunction = obj.sayHi.bind(obj);
		boundFunction(); // Выведет: "Hello, Alice"
		```
	- ###### Function.prototype.call():
		Метод call() вызывает функцию с указанным значением this и аргументами,
		переданными в виде списка.

		```JS
		const obj1 = {
  			name: 'Alice',
		};

		const obj2 = {
			name: 'Bob',
		};

		function sayHi() {
			console.log('Hello, ' + this.name);
			}

		sayHi.call(obj1); // Выведет: "Hello, Alice"
		sayHi.call(obj2); // Выведет: "Hello, Bob"
		```

	- ###### Function.prototype.apply():
		Метод apply() работает аналогично методу call(), но принимает аргументы в виде массива.

		```JS
		const obj1 = {
			name: 'Alice',
		};

		const obj2 = {
			name: 'Bob',
		};

		function sayHi() {
			console.log('Hello, ' + this.name);
		}

		sayHi.apply(obj1); // Выведет: "Hello, Alice"
		sayHi.apply(obj2); // Выведет: "Hello, Bob"
		```

	Эти методы позволяют явно указывать, к чему должно ссылаться ключевое слово this внутри функции, независимо от контекста вызова. Они полезны, когда мы хотим управлять значением this и передавать функцию с определенным контекстом другим функциям или методам.

# Особенности bind
    Метод bind() доступен у функций, и в его задачу входит связывание функции с каким-то контекстом. Результатом выполнения bind() будет новая функция, работающая как и исходная функция, но с привязанным к ней контекстом. Связанная функция сливается со своим контекстом "намертво". Больше this не поменяется. Подход с bind() был популярен до появления стрелочных функций, сейчас его используют нечасто. Стрелочные функции проще для понимания и используются повсеместно.

	- ###### Создание новой функции:
		 Метод bind() не вызывает функцию немедленно. Вместо этого, он создает и возвращает новую функцию с явно указанным значением this. Это позволяет сохранить привязку контекста и передать эту функцию другим функциям или методам для последующего вызова.
	- ###### Переопределение контекста: bind():
		 Позволяет явно указать контекст выполнения для функции, независимо от того, каким образом функция была вызвана. Это может быть полезно, когда необходимо привязать метод объекта к определенному контексту или передать функцию с определенным контекстом в коллбэки или обработчики событий.

	- ###### Частичное применение: bind():
		 Также позволяет частичное применение аргументов функции. Это означает, что мы можем предварительно указать значения для некоторых аргументов, а оставшиеся аргументы передать при вызове привязанной функции.
		```JS
		function add(a, b) {
 	 		return a + b;
		}
		const add5 = add.bind(null, 5); // Частичное применение аргумента "a"
		console.log(add5(3)); // Выведет: 8, так как a = 5, b = 3
		```
	- ###### Невозможность изменения привязанного контекста:
		 После привязки контекста с помощью bind(), нельзя изменить привязанный контекст. Значение this будет оставаться неизменным для привязанной функции, даже если мы попытаемся присвоить другое значение this.
		```JS
		const obj = {
  		name: 'Alice',
		};

		function sayHi() {
  		console.log('Hello, ' + this.name);
		}

		const boundFunction = sayHi.bind(obj);
		boundFunction(); // Выведет: "Hello, Alice"

		// Попытка изменить контекст не повлияет на привязанную функцию
		boundFunction.call({ name: 'Bob' }); // Все равно выведет: "Hello, Alice"
		```
