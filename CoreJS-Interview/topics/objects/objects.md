# <a id="obj-create" /> Создать объект через Object.create.

Помимо способов создания объекта через литерал объекта и функцию конструктор, есть возможность создать объект с помощью метода Object.create(proto, propertiesObject?). Метод принимаем в качестве обязательного аргумента другой объект, который будет установлен в качестве прототипа создаваемого объекта.
В качестве второго, необязательного, принимается объект, в котором ключи являются названиями свойств, а значения - их дескрипторами. Подробнее про дескрипторы ниже.

Таким образом, Object.create(), предоставляет больший контроль над процессом создания объекта, позволяя сразу же устанавливать выбранный прототип, определять свойства и методы объекта, а также сразу конфигурировать их.

[MDN Object.create()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

# <a id="descriptors" />Дескрипторы свойств объекта.

Как мы знаем, объект в JS это коллекция пар "Ключ - Значение". Если взглянуть чуть глубже, мы выясним, что под словом значение скрывается не только само значение, но и
атрибуты (также называемые "флаги"), которые описывают свойство объекта. Помимо самого значения "value", их три:

* writable – если true, свойство можно изменить, иначе оно только для чтения.
* enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
* configurable  – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

По умолчанию эти атрибуты скрыты, и обратившись к свойству объекта по ключи мы получим только значение "value".

Чтобы получить полное описание свойства, необходимо использовать метод Object.getOwnPropertyDescriptor(obj, propertyName), который первым аргументом принимает целевой объект, а вторым имя свойства, описание которого мы хотим получить. В результате выполнения, метод вернет объект, который и называется property descriptor (дескриптор свойства).

Пример:
```JS
      let user = {
        name: "John"
      };

      let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
      /* дескриптор свойства:
        {
          "value": "John",
          "writable": true,
          "enumerable": true,
          "configurable": true
        }
      */
```

Чтобы изменить дескриптор, следует использовать метод Object.defineProperty(obj, propertyName, descriptor), который принимает первый аргументом целевой объект, вторым имя свойства, и третьим объект-дескриптор. Следует помнить, что если в объекте-дескрипторе не будут указаны какие-то флаги, то их значение будет автоматически установлено false, что, если мы сделали это неосознанно, может повлечь за собой неочевидные проблемы в работе кода, в виде неизменяемого свойства, или свойства которое мы никак не сможем увидеть при перечислении.

[MDN Object.defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
[LearnJS Property descriptor](https://learn.javascript.ru/property-descriptors)


# <a id="copy-obj" />Как копировать объект. Глубоко и нет. Нюансы JSON.stringify при копировании объекта.

Объект передается по ссылке. Это значит, что при попытке скопировать объект через обычное присвоение, мы всего лишь создадим еще одну ссылку на исходный объект, но не его копию.

Есть два вида копирования, поверхностное, когда мы копируем свойства одного объекта, в свойства другого, при это если значение свойства копируемого объекта, в свою очередь является объектом, то копирования не произойдет, а создастся ссылка на тот же самый объект. В итоге мы получим два разных объекта, которые внутри себя будут ссылаться на одни и те же объекты.

Чтобы этого избежать, используется глубокое копирование, которое создает копию не только копируемого объекта, но и всех вложенных, в результате чего мы получим два полностью независимых объекта.

Для поверхностного копирования подходят методы:
* Object.assign(target, ...sources), который первым аргументом принимает целевой объект, а последующими - исходные объекты, из которых будут скопированы все  _собственные_ и _перечисляемые_ свойства (помним про флаг enumerable, в дескрипторе свойства). К примеру следующий код создаст новый объект, скопировав туда все свойства объектов one и two, а затем запишет ссылку на него в переменную copy.
```JS
  let copy = Object.assign({}, one, two);
```
* Синтаксис деструктуризации. Следующий код создаст копии свойств объекта one, затем "соберет" их в новый объект, ссылку на который, запишет в переменную copy
```JS
  let copy = {...one};
```

С глубоким копированием сложнее, в части случаев, его можно выполнить комбинацией методов JSON.stringify() и JSON.parse(). Первый рекурсивно обойдет объект, и вернет его строчное представление в формате JSON, а второй десериализует это значение,  создав из него новый объект. Т.к. мы создаем новый объект из строки, мы избегаем любых связей между исходным и копируемым объектом. Главной проблемой, не позволяющей использовать этот подход всегда и везде, является то, что при преобразовании исходного объекта в JSON строку, пропускаются и, соответственно теряются при копировании, все
* Свойства-функции (методы).
* Символьные ключи и значения.
* Свойства, содержащие undefined.

Для полноценного глубокого копирования нет встроенных методов, способ с JSON не подходит, следует либо использовать сторонние библиотеки, либо писать функцию для глубокого копирования самостоятельно.

[MDN Object.assign()](https://developer.mozilla.org/en-US/doc    s/Web/JavaScript/Reference/Global_Objects/Object/assign)
[LearnJS JSON](https://learn.javascript.ru/json)
[LearnJS Spread operator](https://learn.javascript.ru/rest-parameters-spread-operator#spread-operator)

# <a id="keys-values" />Перечисли встроенные методы объекта, для получения ключей, значений, и ещё один похожий метод.
* Object.keys(source) - вернет массив ключей (названий свойств) объекта, переданного в качестве аргумента.
* Object.values(source) - вернет массив значений свойств объекта, переданного в качестве аргумента.
* Object.entries() - вернет массив собственных перечисляемых свойств указанного объекта в формате [key, value], в том же порядке, что и в цикле for...in

Следует помнить, что все вышеперечисленные методы игнорируют неперечисляемые свойства (флаг enumerable в дескрипторе свойства)

[MDN Object.keys()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)
[MDN Object.values()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values)
[MDN Object.entries()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)

# <a id="map-set" />Что такое Map и Set? Чем Map отличается от объекта.
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа (в т.ч другие объекты).
Данная структура данных для работы использует следующие методы:

* new Map() – создаёт коллекцию.
* map.set(key, value) – записывает по ключу key значение value.
* map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
* map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
* map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
* map.clear() – очищает коллекцию от вс    ех элементов.
* map.size – возвращает текущее количество элементов.
* map.keys() – возвращает итерируемый объект по ключам,
* map.values() – возвращает итерируемый объект по значениям,
* map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.

Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Данная структура данных для работы использует следующие методы:

* new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
* set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
* set.delete(value) – удаляет значение, возвращает true, если value было  в множестве на момент вызова, иначе false.
* set.has(value) – возвр    ащает true, если значение присутствует в множестве, иначе false.
* set.clear() – удаляет все имеющиеся значения.
* set.size – возвращает количество элементов в множестве.

Основным преимуществом структуры является то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

Перебор возможен как с помощью метода for..of, так и используя forEach (в отличие от перебора методом forEach обычных массивов, при переборе Set callback принимает три аргумента: value, valueAgain, index. Это сделано для совместимости с объектом Map).

[LearnJS Map and Set](https://learn.javascript.ru/map-set)

# <a id="obj-is" />Что делает метод Object.is
Метод проверяет, являются ли значения _одинаковыми_. Метод не пытается выполнить приведение типов как нестрогое равенство, и в отличие от строгого равенства не считает +0 и -0 равными, а также считает NaN равному NaN.

Метод применяется во внутренних реализациях некоторых методов языка. К примеру, при попытке изменения неизменяемого свойства, вызов Object.defineProperty выбросит ошибку, однако, если новое свойство равняется старому, изменений не произойдёт и ошибки не будет. Для проверки равно ли новое свойство старому используется Object.is()

[MDN Object.is()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
[MDN Sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)



# <a id="freeze" />Что делают методы Object.freeze() и Object.seal().
Оба методы нужны для придания объекту иммутабельности (защиты от изменений).   
Метод Object.seal(obj) запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми.   
Допускается только изменять значение уже существующих свойств.   
    
Метод Object.freeze(obj) замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту,    
удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемо сти и записываемости.    
Фактически объект становится полностью неизменным. Однако остается возможность изменять внутренние "подобъекты", если они, в свою очередь,    
не были заморожены или запечатаны.   


Для проверки, является ли объект замороженным или запечатанным используются методы Object.isSealed(obj), Object.isFrozen(obj)

[MDN Object.freeze()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
[MDN Object.seal()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
