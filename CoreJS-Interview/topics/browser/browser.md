# <a id="dom" /> Что такое DOM?

DOM — это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML-кода, полученного им от сервера.

# <a id="document" /> Что такое document?

Объект document позволяет работать со всей HTML структорой сайта за счёт языка JavaScript. Document является корневым объектом в DOM-структуре сайта.

# <a id="bom" /> Что такое BOM?
  
Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
<img width="775" alt="Снимок экрана 2023-07-13 в 18 59 13" src="https://github.com/olgamarkevich/Core-JS-Interview/assets/46402735/56a358cf-380d-4465-98fe-f3bcbf6de802">

# <a id="cssom" /> Что такое CSSOM?
  
CSS Object Model представляет собой набор API-интерфейсов, позволяющих манипулировать CSS из JavaScript. Это очень похоже на DOM, но для CSS, а не HTML. Это позволяет пользователям динамически читать и изменять стиль CSS
  
# <a id="dom-serch" /> Поиск элементов в DOM
  
Для поиска элементов на странице применяются следующие методы:

* getElementById(value): выбирает элемент, у которого атрибут id равен value, если элемента с таким идентификатором нет, то возвращается null
* getElementsByTagName(value): выбирает все элементы, у которых тег равен value
* getElementsByClassName(value): выбирает все элементы, которые имеют класс value
* querySelector(value): выбирает первый элемент, который соответствует css-селектору value
* querySelectorAll(value): выбирает все элементы, которые соответствуют css-селектору value

# <a id="collections" /> Живые и неживые коллекции
  
Методы семейства getElementsBy* возвращают “живые" коллекции, в то время как метод querySelectorAll возвращает “неживые” (статические).
Отличие “живой” коллекции от “неживой” заключается в том, что первая как бы синхронизируется (сразу же реагирует на изменения) с текущим состоянием документа, а вторая — нет.
Например, если мы сначала получим все элементы с классом cell при помощи метода getElementsByClassName, а затем удалим из документа один из них, то в нашей коллекции он также исчезнет. Если же мы проделаем всё тоже самое, но вместо getElementsByClassName используем querySelectorAll, то даже после удаления элемента из DOM наша коллекция не изменится.

# <a id="events" /> Браузерные события
Виды событий:
+ cобытия мыши (click, dblclick, contextmenu, mouseover / mouseout, mousedown / mouseup, mousemove)
+ cобытия на элементах управления (submit, focus)
+ клавиатурные события (keydown, keyup)
+ cобытия документа (DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен)
+ CSS events (transitionend, animationstart, animationiteration)
+ cобытия объектов и фреймов (load, resize)
+ cобытия перетаскивания (drag, dragstart, dragend)
  	  
# <a id="phases" /> Фазы события
  
Стандарт DOM Events описывает 3 фазы прохода события:
- фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
- фаза цели (target phase) – событие достигло целевого(исходного) элемента.
- фаза всплытия (bubbling stage) – событие начинает всплывать.

# <a id="event-listeners" /> Обработчик событий, как повесить, как убрать. Какой нюанс, если мы хотим удалить обработчик
  
Обработчик события — это функция, которая срабатывает в момент возникновения события. В JavaScript обработчики событий можно навешивать несколькими способами.
  
- с помощью атрибута HTML

Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>
    
```JS
  <input type="button" onclick="alert('Клик!')" value="Кнопка">
```
- использовать свойства  DOM-объекта
```JS
  <input id="elem" type="button" value="Нажми меня!">
  <script>
  	elem.onclick = function() {
    alert('Спасибо');
  	};
  </script>
```

- доступ к элементу через this
```JS
  <button onclick="alert(this.innerHTML)">Нажми меня</button>
```
- addEventListener
element.addEventListener(eventName, eventHandler, [options]);
    
Метод addEventListener принимает три аргумента:
+ eventName – название события, на которое назначается обработчик (например, ‘click’ или ‘mouseout’);
+ eventHandler – функция-обработчик;
+ ?options – необязательный параметр, который может быть или объектом со свойствами { ?capture, ?once, ?passive }, или значением true/false, что будет аналогично записи { capture: true/false }.

Есть два способа удалить обработчик, назначенный с помощью addEventListener:
- метод removeEventListener, который удаляет обработчик по ссылке.
   
Метод removeEventListener(eventName, eventHandler, ?capture) принимает три параметра, два из которых точно такие же, как у метода addEventListener. Третий параметр требует указания фазы, с которой снимается обработчик. То есть если обработчик был назначен на стадию погружения, то и удаляться он должен с этой же фазы. В ином случае ничего не удалится.
   
- во время назначения обработчика третьим параметром передать объект со значением once равным true. После первого срабатывания обработчик будет автоматически удалён.

# <a id="prevent-default" /> Event.preventDefault()
  
это метод объекта события JavaScript, который используется для отмены действия браузера по умолчанию, связанного с определенным событием

Кроме event.preventDefault() действие по умолчанию можно отменить с помощью возвращения значения false в теле функции-обработчика. Однако такой подход сработает только если обработчик назначен через атрибут или свойство (т.е. не с помощью метода addEventListener).
  
# <a id="stop-propagandation" /> Как предотвратить распространение события
  
+ event.stopPropagation() — прекращение дальнейшего распространения события. Т.е. после вызова этого метода, event завершит погружение (или всплытие) и ни один из оставшихся обработчиков на других событиях вызван не будет;
+ event.stopImmediatePropagation() — тоже, что и event.stopPropagation(), но в дополнение предотвращение вызова других обработчиков на текущем элементе. Т.е. если на одном элементе висит сразу три обработчика на ‘click’, вызов event.stopImmediatePropagation() в одном из них предотвратит вызов оставшихся.
  
# <a id="delegate" /> Что такое делегирования событий
  
Делегирование событий является полезным шаблоном, так как позволяет отслеживать события на множестве элементов с помощью только одного обработчика.

Для работы делегирования событий нужно 3 шага:
+ определить родителя элементов для отслеживания событий
+ прикрепить на него обработчик событий
+ использовать event.target для выбора целевого элемента

