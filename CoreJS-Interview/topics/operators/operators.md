# <a id="compare" />Перечислите операторы сравнения

  `==, ===` нестрогое и строгое равенство    
  `>, <` больше/меньше   
  `>=, <=`  больше/меньше или равно   
  `!=, !==` нестрогое и строгое неравенство    
  
# <a id="strict-and-lax" />Разница между `==` и `===`

Оператор строгого равенства === проверяет равенство без приведения типов, нестрогое равестно старается привести типы к одному.

```JS
  alert( 0 == false ); // true
  alert( '' == false ); // true

  alert( 0 === false ); // false

```
# <a id="logical" />Перечислите логические операторы   

  В JavaScript есть четыре логических оператора:   
  `&& (И), || (ИЛИ), ! (НЕ), ?? (оператор нулевого слияния, см. след вопрос)`
1. || возвращает первое истинное значение или последнее ложное
    ```JS
    alert( null || 1 ); // 1 (первое истинное значение)
    alert( null || 0 || 1 ); // 1 (первое истинное значение)
    alert( undefined || null || 0 ); // 0 (последнее ложное значение)
    ```
2. && возвращает первое ложное значение или последнее истинное
    ```JS
    alert( 1 && 2 && null && 3 ); // null (первое ложное значение)
    alert( 1 && 5 ); // 5 (последнее истинное значение)
    ```
   Оператор && имеет больший приоритет, чем ||, так что он выполняется раньше.    
 3. Оператор НЕ представлен восклицательным знаком !.  
   Оператор принимает один аргумент и выполняет следующие действия:   
     -Сначала приводит аргумент к логическому типу true/false.   
     -Затем возвращает противоположное значение.   
   В частности, двойное НЕ !! используют для преобразования значений к логическому типу.    
   Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.
	
# <a id="zero-merge" />Что такое оператор нулевого слияния?
  
  Оператор нулевого слияния представляет собой два вопросительных знака ??. Оператор нулевого слияния возвращает первый определнный аргумент, иначе последний.   
  Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе последний.

```JS
  let user1;
  alert(user1 ?? "Аноним"); // Аноним

  let user2 = "Иван";
  alert(user2 ?? "Аноним"); // Иван (user2 существует)

  console.log(false ?? null) //false (false определен)
```

# <a id="merge-logical" />В чем разница ?? с логическим ИЛИ

  Важное различие между ними заключается в том, что:    
  || возвращает первое истинное значение или последнее ложное.   
  ?? возвращает первое определённое значение.   
  Проще говоря, оператор || не различает разницы между falsy values, они все для него являются ложными значениями.   
  В то время, для оператора ?? определены только два ложных значения: null и undefined.   
```JS
  console.log(false ?? null) //false (false определен для ??)
  console.log(false || null) //null (|| возвращает последний false)
```
  
# <a id="falsy-values" />Перечислите falsy values

  Ложноподобное (falsy) значение — значение, которое становится false в булевом контексте.   
  `0, '', NaN, null, undefined, false`
  
# <a id="important" />Важные моменты при работе с операторами сравнения:

  При нестрогом равенстве `==` undefined и null равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
  ```md
	 null == undefined // true
  ```
  При строгом равенстве `===` эти значения различны, так как различны их типы.
  ```md
	 null === undefined // false
  ```
  Ссылочные типы данных не равны друг другу, т.к. это независимые друг от друга объекты/массивы с разными ссылками. Даже если у них абсолютно одинаковое 
  наполнение.
   ```JS
	 {}=={} // false
	 {}==={} //false
	 []==[] //false
	 []===[]// false
   ```

 # <a id="null-undefined" />К чему приводятся null и undefined при использовании математических операторов и операторов сравнения.

   При работе с математическими операторами `null` приводится к `0`, а `undefined` к `NaN`.   
   Сравним `null` с нулём:
   ```JS
   alert( null > 0 );  // (1) false
   alert( null == 0 ); // (2) false
   alert( null >= 0 ); // (3) true
   ```

   С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений 
   выше должен быть true, но они оба ложны.

   Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому 
   выражение (3) null >= 0 истинно, а null > 0 ложно.

   С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и 
   не равны ничему другому. Поэтому (2) null == 0 ложно.

   Значение undefined несравнимо с другими значениями:
   ```JS
   alert( undefined > 0 ); // false (1)
   alert( undefined < 0 ); // false (2)
   alert( undefined == 0 ); // false (3)
   ```
   Почему же сравнение undefined с нулём всегда ложно?

   На это есть следующие причины:

   Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых 
   сравнениях.
   Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.
