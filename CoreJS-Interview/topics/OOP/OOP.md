# <a id="oop" />Что такое OOP

Объектно-ориентированное программирование – это подход/методология, при котором вся программа рассматривается как набор взаимодействующих друг с другом объектов. У каждого объекта в системе есть свойства и поведение(методы). Такой подход помогает строить сложные системы более просто и естественно благодаря тому, что вся предметная область разбивается на объекты и каждый из них слабо связан с другими объектами.

Основные задачи ООП — структурировать код, повысить его читабельность и ускорить понимание логики программы. Косвенно выполняются и другие задачи: например, повышается безопасность кода и сокращается его дублирование.

Основные принципы, на которые опирается ООП парадигма:

<b>

1. Инкапсуляция
2. Полиморфизм
3. Наследование
4. Абстракция

</b>
<br><br>

Одна из [лучших прочитанных мною статей](https://habr.com/ru/articles/463125/) не тему ООП. И [ещё одна](https://habr.com/ru/articles/345658/)

# <a id="encapsulation" />Что такое инкапсуляция

Инкапсуляция – сокрытие поведения и данных объекта внутри него, способ спрятать сложную логику внутри объекта, предоставив пользователю лаконичный и понятный интерфейс для взаимодействия с сущностью. Вам не нужно знать как в мельчайших деталях работает кофеварка, её внутреннее устройство. Вы просто знаете, что нужно поставить чашку, засыпать кофе, налить воды и нажать кнопку. Детали работы скрыты, для пользования предоставлен удобный интерфейс. Приватные поля и методы, геттеры и сеттеры.

# <a id="inheritance" />Что такое наследование

Наследование - это форма отношений между классами. Один класс может наследовать другой класс, его поля и методы. Наследовать - означает переиспользовать. После того, как класс объявляет себя наследником какого-то класса, соответствующие поля и методы появляются в нем автоматически. Наследник берёт от родителя его методы и свойства, и дополняет их, либо переопределяет, своими методами и свойствами. Сотрудник/менеджер, прямоугольник/квадрат, публикация на сайте/статья или объявление.

# <a id="polymorphism" />Что такое полиморфизм

Полиморфизм - это переопределение поведения. Способность функции использовать данные разных типов, и действовать по разному в зависимости от этих данных. Один интерфейс: много реализаций. Углерод может быть и в форме алмаза, и в форме графита, и в форме карбона.
<br><br>

<b>Разделяют два вида полиморфизма:</b>

- Параметрический полиморфизм, который позволяет описывать вычисления в общем виде, абстрагируясь от того, какие типы будут использованы Параметрически полиморфные функции еще также называются обобщенными (Generic).

- Специальный полиморфизм. В нем происходит диспетчеризация (перенаправление) к одной или нескольким функциям для конкретного типа аргумента.

Из этого можно сделать следующие выводы:

- Универсально полиморфные функции работают на неограниченном количестве типов, причем функция будет выполняться для любого типа аргументов.
		Пример: функция сортировка массива: ей без разницы что сортировать, числа, строки, или кошек с собаками. Так же неявное приведение типов считается полиморфизмом.

- Специально полиморфные функции работают с конечным набором конкретных типов, не связанных между собой, где для каждого типа аргументов реализуется свой способ вычислений.

Перегрузка — это разновидность специального полиморфизма. Такой вид полиморфизма позволяет объявлять функции с одним и тем же именем, но с разными типами аргументов и их количеством (арностью).
Пример:

```JS
			class Manager {
				constructor(name) {
						this.name = name;
				}
				greet() {
						return `I'm ${this.name} and I do very important work!`
				}
			}

			class SeniorManager extends Manager {
					constructor(name) {
							super(name)
					}
					greet() {
							return `${super.greet()} That you can't even imagine!`
					}
			}

			const pete = new Manager('Pete');
			const alan = new SeniorManager('Alan');

			console.log(pete.greet()) // I'm Pete and I do very important work!
			console.log(alan.greet()) //I'm Alan and I do very important work! That you can't even imagine!
```

Немного другая схема полиморфизма:
<br><br>
<img src="./OOP-topic-imgs/Polymorphism.webp" style="display:block;float:none;margin-left:auto;margin-right:auto;width:400px">


По ходу, ни один принцип ООП не обладает такой противоречивой информацией, и не вызывает так много дискуссий как полиморфизм. Очень объемная [статья на медиуме](https://medium.com/devschacht/polymorphism-207d9f9cd78) по этому поводу.

# <a id="association" />Что такое ассоциация

Ассоциация – это один из способов взаимодействия между классами, когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Если наследование описывается словом "является". "А" является сущностью "Б", то ассоциация описывается словом "имеет/владеет". "А" владеет сущностью "Б". Сама ассоциация имеет два частных случая: композицию и агреггацию.

# <a id="composition" />Что такое композиция

Композиция - это когда вложенный объект не существует отдельно от класса, в который он включён. Другими словами, жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.

# <a id="aggregation" />Что такое агрегация

Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра. То есть, жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может использоваться другими объектами.

# <a id="abstract-class" />Что такое абстрактный класс

Некий базовый класс, который не предполагает создания экземпляров. Мы <b>НЕ МОЖЕМ</b> использовать конструктор абстрактного класса для создания экземпляра класса. Абстрактные классы реализуют на практике один из принципов ООП — полиморфизм. Абстрактный класс может содержать (или не содержать) абстрактные методы и свойства. Например, в реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами.

# <a id="interface" />Что такое интерфейс

Интерфейс описывает только поведение (методы) класса. Главное отличие класса от интерфейса — в том, что класс состоит из интерфейса и реализации. Интерфейс — то, что доступно при использовании класса извне.

Более [подробно](https://habr.com/ru/articles/30444/)

# <a id="abstract-method" />Что такое абстрактный метод

Абстрактный метод - это некий метод, который задан, но ещё не определен, метод, реализация которого ещё отутствует. Абстрактный метод подлежит определению в классах-наследниках

# <a id="static-method" />Что такое статический метод

Метод принадлежащий самому классу, и не имеющий доступа к состоянию (полям) объекта, то есть к переменной this. В объявлении класса помечается ключевым словом static

# <a id="static-prop" />Что такое статическое свойство

Свойство принадлежащее самому классу, и не имеющее доступа к состоянию (полям) объекта, то есть к переменной this. В объявлении класса помечается ключевым словом static. Статические свойства и методы наследуются.

# <a id="instance" />Что такое инстанс и инстанцирование

Непосредственный экземпляр класса, его физическое воплощение. Сущность, которая занимает место в памяти, владеет всеми полями и методами класса.

# <a id="decorator" />Что такое декоратор

Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки». Суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё. В основе лежит агрегация или композиция.

Пример: любая одежда — это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

В TS декораторы объявляются через @decoratorName; В ванильном JS синтаксис декораторов не поддерживается. Но вы всё ещё можете писать свои декораторы самостоятельно. Все следующие примеры по декораторам будут написаны на TS.
Отличная полноценная [статья](https://habr.com/ru/companies/otus/articles/531664/) по декораторам в JS.

# <a id="class-decorator" />Что такое декоратор класса

Это функция, которая оборачивает инстанс класса. С помощью декоратора, мы можем динамически добавлять обьектам новые свойства и методы. То есть мы как бы заворачиваем наш обьект в декоратор, как в superclass.

Декоратор sealed с помощью функции Object.seal запрещает расширение прототипа класса User:

```TS
		function sealed(constructor) {
			console.log("sealed decorator");
			Object.seal(constructor);
			Object.seal(constructor.prototype);
		}

		@sealed
		class User {
				constructor(name){
						this.name = name;
				}
				print() {
						console.log(this.name);
				}
		}
```

# <a id="method-decorator" />Что такое декоратор метода

Декоратор метода также представляет функцию, которая принимает три параметра:

Декоратор принимает следующие параметры:

1. Функция конструктора класса для статического метода, либо прототип класса для обычного метода.
2. Название метода.
3. Объект интерфейса PropertyDescriptor.

Декоратор readable с помощью выражения descriptor.writable = false; устанавливает, что метод, к которому применяется данный декоратор, не может быть изменен.

```TS
		function readable (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    	descriptor.writable = false;
		};

		class User {
				constructor(name){
						this.name = name;
				}

				@readable
				print() {
						console.log(this.name);
				}
		}
		let tom = new User("Tom");
		tom.print = function(){console.log("print has been changed");}
		tom.print();  // Tom
```

# <a id="prop-decorator" />Что такое декоратор свойства

Декоратор свойства представляет функцию, которая принимает два параметра: первый параметр представляет конструктор класса, если свойство статическое, либо прототип класса, если свойство нестатическое, а второй параметр представляет имя свойства.

```TS
		function format() {
			return function(target, propertyKey) {
				let value;
				const getter = function() {
					return "Mr./Ms." + value;     // изменяем возвращаемое значение
				};
				const setter = function(newVal) {
					if(newVal.length > 2) {   // добавляем проверку на длину строки
							value = newVal
					}
				};
				// устанавливает геттер и сеттер для свойства
				Object.defineProperty(target, propertyKey, {
					get: getter,
					set: setter
				});
			}
		}

		class User {
			@format
			constructor(name){
					this.name = name;
			}
			print() {
					console.log(this.name);
			}
		}
		let tom = new User("Tom");
		tom.print();
		tom.name = "Tommy";
		tom.print();
		tom.name = "To";
		tom.print();
```

# <a id="param-decorator" />Что такое декоратор параметра

Декоратор параметра объявляется прямо перед объявлением параметра. Функция декоратора принимает 3 параметра.

1. конструктор класса, если метод статический, либо прототип класса, если метод нестатический.
2. имя метода
3. порядковый индекс параметра в списке параметров.

Декоратор logParameter добавляет в прототип класса новое свойство metadataKey. Это свойство представляет массив, который содержит индексы декорированных параметров.

Для чтения метаданных из свойства metadataKey применяется декоратор метода logMethod, который перебирает все параметры метода, находит значения параметров по индексам, которые определены декоратором параметра, и выводит на консоль названия и значения декорированных параметров.

```TS
		function logParameter(target: any, key : string, index : number) {
			var metadataKey = `__log_${key}_parameters`;

			if (Array.isArray(target[metadataKey])) {
					target[metadataKey].push(index);
				}
				else {
					target[metadataKey] = [index];
			}
		}
		function logMethod(target: any, key: string, descriptor: PropertyDescriptor) {

				var originalMethod = descriptor.value;
				descriptor.value = function (...args: any[]) {

						var metadataKey = `__log_${key}_parameters`;
						var indices = target[metadataKey];

						if (Array.isArray(indices)) {
								for (var i = 0; i < args.length; i++) {

										if (indices.indexOf(i) !== -1) {
												var arg = args[i];
												var argStr = JSON.stringify(arg) || arg.toString();
												console.log(`${key} arg[${i}]: ${argStr}`);
										}
								}
								var result = originalMethod.apply(this, args);
								return result;
						}
						else {
								var a = args.map(a => (JSON.stringify(a) || a.toString())).join();
								var result = originalMethod.apply(this, args);
								var r = JSON.stringify(result);
								console.log(`Call: ${key}(${a}) => ${r}`);
								return result;
						}
				}
				return descriptor;
		}

		class User {

				private name: string;
				constructor(name: string){
						this.name = name;
				}
			@logMethod
				setName(@logParameter name: string){
						this.name = name;
				}
				print():void{
						console.log(this.name);
				}
		}
		let tom = new User("Tom");
		tom.setName("Bob");
		tom.setName("Sam");
```

# <a id="get-set-decorator" />Что такое декоратор геттера и сеттера

Декоратор метода доступа принимает три параметра:
1. конструктор класса для статического метода, либо прототип класса для обычного метода.
2. название метода.
3. объект PropertyDescriptor.

```JS
		function validator(target, propertyKey, descriptor) {
			const oldSet = descriptor.set;

			descriptor.set = function(value) {
					if (value === "admin") {
							throw new Error("Invalid value");
					}
					if(oldSet!==undefined) oldSet.call(this, value);
			}
		}
		class User {
			constructor(name){
					this.name = name;
			}

			get name() {
					return this._name;
			}
			@validator
			set name(n) {
					this._name = n;
			}
		}
		let tom = new User("Tom");
		console.log(tom.name);
		tom.name= "admin";
		console.log(tom.name);
```

# <a id="func-decorator" />Что такое декоратор функции

Декораторы функций — это такие же функции. Они принимают функцию в качестве аргумента и возвращают другую функцию, которая расширяет поведение функции-аргумента. Новая функция не изменяет функцию-аргумент, но использует ее в своем теле. Как я уже говорил, это во многом напоминает функции высшего порядка.

Самый простой пример - валидация параметров функции. Ванильный JS.

```JS
		//decorator function
	const allArgsValid = function(fn) {
		return function(...args) {
		if (args.length != fn.length) {
				throw new Error('Only submit required number of params');
			}
			const validArgs = args.filter(arg => Number.isInteger(arg));
			if (validArgs.length < fn.length) {
				throw new TypeError('Argument cannot be a non-integer');
			}
			return fn(...args);
		}
	}

	//ordinary multiply function
	let multiply = function(a,b){
		return a*b;
	}

	//decorated multiply function that only accepts the required number of params and only integers
	multiply = allArgsValid(multiply);
	multiply(6, 8); // 48
	multiply(6, 8, 7); // Error: Only submit required number of params
	multiply(3, null); // TypeError: Argument cannot be a non-integer
	multiply('',4); // TypeError: Argument cannot be a non-integer
```
