# Вопросы CoreJS

## ТИПЫ ДАННЫХ:

- Перечислите все типы данных

1. Число (Number): представляет числовые значения, например, 42 или 3.14. Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.
2. BigInt: представляет целочисленные значения произвольной точности, больше, чем максимальное значение, которое может
	 быть представлено типом Number без потери точности. Значения типа bigint можно получить при помощи добавления символа n в конец числового литерала или же при помощи вызова встроенной функции BigInt().
3. Строка (String): представляет последовательность символов, например, "Привет"
4. Булевый (логический) тип (Boolean): может принимать только два значения: true (истина) или false (ложь).
5. Специальное значение null: это значение не относится ни к одному из типов выше, а образует отдельный тип, состоящий
	 из единственного значения null. Говорит об отсутсвии значения. ЗНАЧЕНИЯ НЕТ. ПУСТО.
6. Специальное значение undefined: это значение также не относится ни к одному из типов выше, и образует отдельный тип,
	 состоящий из единственного значения undefined. Это значение отражает то, что значение не задано. Например, созданная, но не проиницилизированная переменная по умолчанию содержит значение undefined. В объекте при попытке получить значение по ключу, которого там нет, будет  получено значение undefined. Также любая функция по умолчанию возвращает значение undefined.

7. Символ (Symbol): представляет уникальное и неизменяемое значение, которое может использоваться в качестве
	 идентификатора для свойств объектов. Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.   
Так же существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов.   
Например:   
Symbol.iterator      
Symbol.toPrimitive   
и пр. [см. тут](https://tc39.es/ecma262/#sec-well-known-symbols)   
9. Объект (Object): представляет неупорядоченную коллекцию ключ-значение. Где ключ – строка или символ (обычно строка), а значение может быть чем угодно. Может содержать свойства и методы. В отличие от всех предыдущих типов данных, object является ссылочным типом. Это означает то, что работа со всеми объектами в JavaScript ведётся по ссылке. Ни одна переменная в JavaScript не содержит объектов. Все они лишь ссылаются на них в памяти.

 - Как узнать какой типа данных перед нами?
     
    Оператор typeof возвращает тип аргумента. Унарный оператор typeof возвращает строку, указывающую тип необязательного
	 операнда. Пример:
	  ```JS
	 typeof 42 === 'number'
	 typeof 'blabla' === 'string'
	 typeof undefined === 'undefined'
	 typeof true === 'boolean'
	 typeof {a: 1} === 'object'
	 typeof Symbol() === 'symbol'
	 typeof null === 'object'
	 typeof function() {} === 'function'
	 ```

- Почему typeof null === 'object'?
  
  Это официально признанная ошибка в языке, которая сохраняется для совместимости. На самом деле null – это не объект, а отдельный тип данных.
  
- Почему typeof function() {} === 'function'?
   
  Функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но typeof выделяет функции отдельно, возвращая для них "function". На практике это весьма удобно, так как позволяет легко определить функцию.
  
- В чем их разница между null и undefined?
  
  undefined - получается при попытке получить значение там, где значения нет.   
  null — явное «зануливание» переменной (object = null), когда ссылка на объект больше не требуется.    
	Упрощённо: JavaScript использует undefined, а программисты должны использовать null.    
  
-  Как создать объект? (три способа)
  
1. С использованием литерального синтаксиса: const person = {};   
2. С использованием ключевого слова «new»: const person = new Object();   
3. Использовать метод Object.create(proto, properties) - где    
     proto - oбъект, который должен быть прототипом вновь созданного объекта,    
     properties - необязательный, можно указать дескртипторы свойст объекта - [настройки конфигурации объекта](https://learn.javascript.ru/property-descriptors)
   
-  Что такое NaN? typeof NaN.
  
   NaN - это результат любого бессмысленного вычисления (ошибка), например:
   ```JS
   console.log( "не число" / 2 ) // NaN
   ```
   Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (с одним исключением):
   ```JS
   console.log( NaN + 1 ) // NaN
   console.log( NaN * 10 ) // NaN
   console.log( NaN ** 0 ); // 1 (исключение)
   ```
   Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.
   Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.
   ```JS
   typeof NaN === "number"
   ```

- NaN === NaN ? Почему?

   Так как NaN - это результат любого бессмысленного вычисления, он не равен результату какого-то другого бессмысленного вычисления. Поэтому:
  
   ```JS
   NaN == NaN // false
   NaN === NaN // false
   NaN !== NaN // true
   ```

- Тогда как узнать что перед нами NaN?

  Использовать метод Number.isNaN() или функцию isNaN(). Обратите внимание на разницу между ними:   
  isNaN() вернёт true, если значение в настоящий момент является NaN, или если оно станет NaN после того, как преобразуется в число:   
  ```JS
  isNaN(NaN); // true
  isNaN('hello world');// true
  ```
  Number.isNaN() вернёт true, только если текущим значением является NaN:   
    ```JS
  Number.isNaN(NaN); // true
  Number.isNaN('hello world');// false
  ```

-  Что такое Infinity?   
  
  Infinity является числовым значением, представляющим математическую бесконечность и сохраняет его поведение.
  ```JS
  typeof Infinity === "number"
  console.log(Infinity + 1); // Infinity 
  console.log(Math.pow(10, 1000)); // Infinity 
  console.log(Math.log(0)); // -Infinity 
  console.log(1 / Infinity); // 0 
  ```
- isFinite() что это за функция?
  
  Oпределяет, является ли переданное значение конечным числом. Если необходимо, параметр сначала преобразуется в число.
  ```JS
  isFinite(Infinity); // false
  isFinite(NaN); // false
  isFinite(-Infinity); // false

  isFinite(0); // true
  isFinite(2e64); // true
   ```
- 0.1 + 0.2 === 0.3 ? Почему?    
  Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.
  ```JS
  console.log(0.1 + 0.2 === 0.3) // false
  console.log( 0.1 + 0.2 ); // 0.30000000000000004
  ```
  Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в 
  десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.
  Решить эту проблему можно — округлить результат используя метод toFixed(n), где n - необязательный параметр, обозначающий количество цифр после десятичной 
  запятой:
  ```JS
  let sum = 0.1 + 0.2;
  console.log( sum.toFixed(2) ); // 0.30
  ```
  Помните, что метод toFixed всегда возвращает строку.
  
- Числовые методы приведения строки в число.

  Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:
  ```JS
  console.log( +"100px" ); // NaN
  ```
  Чтобы «читать» числа из строк, в JS предусмотрены методы parseInt и parseFloat. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:
  ```JS
  alert( parseInt('100px') ); // 100
  alert( parseFloat('12.5em') ); // 12.5

  alert( parseInt('12.3') ); // 12, вернётся только целая часть
  alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

  alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
  ```
  
- Можем ли к числу применять .toString(). Какая у этого метода особенность?

  Да, можем. Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
  ```JS
  const num = 255;

  console.log( num.toString(16) );  // ff
  console.log( num.toString(2) );   // 11111111
  ```
  Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, то нам надо поставить две точки .. после числа.
  ```JS
  console.log( 123456..toString(36) ); // 2n9c
  ```
  Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, что после первой точки начинается 
  десятичная часть. 

- Что такое Math? Приведите примеры.
  
  Math - это встроенный в JS объект, который предоставляет математические операции и константы. Например:
  Math.PI   
  Math.random()
  и пр. [см. тут](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)   
- Mетоды строк. Как получить подстроку.
1. Строка, итерируемая сущность, поэтому мы имеем доспут к индексам и длине строки:
   str.length, str[0], str.at(0), str.indexOf(substr, pos) и пр.
2. Методы toLowerCase() и toUpperCase() меняют регистр символов.
3. Поиск совпадения includes, startsWith, endsWith
4. Получение подстроки:    
 В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.   
 str.slice(start [, end]) - возвращает часть строки от start до (не включая) end.     
 str.substring(start [, end]) - возвращает часть строки между start и end.   
 str.substr(start [, length]) - возвращает часть строки от start длины length.   
- Что будет в консоли и почему:
	 ```JS
	 let str = "Привет!"
	 str[0]= "п"
	 console.log(str)
	 ```
  
  Будет:
  ```JS
	 console.log(str) // "Привет!"
	 ```
	Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

- Что такое шаблонные строки? Перечисли особенности.

	Шаблонные строки — это ещё один способ создания строк, наравне с одинарными или двойными кавычками. Шаблонные строки объявляются с помощью обратных кавычек.   
  Особенности:    
1. Шаблонная строка может быть многострочной, все переносы строк в ней будут сохранены.   
2. В шаблонной строке с помощью синтаксиса ${ } можно использовать любые выражения JavaScript.   
3. Любой нестроковый результат (например, объект), вне ${ }, будет приведён к строке.   
  
- Что такое конкатенация?

  Операция соединения строк в программировании называется конкатенацией. Объединение строк в JavaScript использует оператор плюс (+).   
  ```JS
	console.log('Dragon' + 'stone')// Dragonstone
	 ```
- Что такое регулярные выражения? Метод для работы с ними. Приведите примеры.

  Регулярные выражения - это шаблоны, используемые для сопоставления последовательностей символов в строках.    
  В JavaScript регулярные выражения реализованы отдельным объектом RegExp и интегрированы в методы строк.   
  Регулярное выражение состоит из шаблона и необязательных флагов.   
  Методы:   
1. Поиск. Метод str.match(regexp) ищет совпадения: все, если есть флаг g, иначе только первое.
2. Замена. Метод str.replace(regexp, replacement) заменяет совпадения с regexp на replacement: все, если у регулярного выражения есть флаг g, иначе только первое.
3. Совпадение. Метод regexp.test(str) возвращает true, если есть хоть одно совпадение, иначе false.

## ПРИВЕДЕНИЕ ТИПОВ ДАННЫХ

- Какие типы данных можно привести? Как? Явно и неявно.

  Виды преобразования типов:   
1. Приведение числа к строке.   
   Явно: с помощью вызова встроенной функции String() `console.log(String(2))` или с помощью вызова метода .toString()(1) `console.log(2..toString(1))`   
   Неявно: с помощью “прибавления” к числу пустой строки. `console.log(2 + '')`   
2. Приведение строки к числу.   
   Явно: с помощью вызова встроенной функции Number() `console.log(Number('22'))` или с помощью вызова встроенных функций parseInt()(1) и parseFloat() 
   `console.log(parseInt('123.123')) // 123
    console.log(parseFloat('123.123')) // 123.123
   ` .   
   Неявно: с помощью унарного оператора ‘+’ `console.log(+'22')`    
3. Приведение значения к логическому типу.   
   Явно: с помощью вызова встроенной функции Boolean() `console.log(Boolean(10))`.    
   Неявно: с помощью двойного использования унарного оператора ‘!’ (не), в условном операторе if, при использовании логических операторов.   

## ОПЕРАТОРЫ:

- Перечислите операторы сравнения
  
  `==, ===` нестрогое и строгое равенство    
  `>, <` больше/меньше   
  `>=, <=`  больше/меньше или равно   
  `!=, !==` нестрогое и строгое неравенство    
  
- Разница между `==` и `===`

	Оператор строгого равенства === проверяет равенство без приведения типов, нестрогое равестно старается привести типы к одному.
  ```JS
  alert( 0 == false ); // true
  alert( '' == false ); // true

  alert( 0 === false ); // false
	```
- Перечислите логические операторы   

  В JavaScript есть четыре логических оператора:   
  `(&& (И), || (ИЛИ), ! (НЕ), ?? (оператор нулевого слияния, см. след вопрос))`   
	
- Что такое оператор нулевого слияния?
  
  Оператор нулевого слияния представляет собой два вопросительных знака ??. Оператор нулевого слияния возвращает первый определнный аргумент, иначе последний.   
  Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе последний.
  ```JS
  let user1;
  alert(user1 ?? "Аноним"); // Аноним

  let user2 = "Иван";
  alert(user2 ?? "Аноним"); // Иван (user2 существует)

  console.log(false ?? null) //false (false определен)
	```
- В чем разница ?? с логическим ИЛИ

  Важное различие между ними заключается в том, что:    
  || возвращает первое истинное значение или последнее ложное.   
  ?? возвращает первое определённое значение.
  Проще говоря, оператор || не различает разницы между falsy values, они все для него являются ложными значениями.
  В то время, для оператора ?? определены только два ложных значения: null и undefined.
  ```JS
  console.log(false ?? null) //false (false определен для ??)
  console.log(false || null) //null (|| возвращает последний false)
	```
  
- Перечислите falsy values

  Ложноподобное (falsy) значение — значение, которое становится false в булевом контексте.   
  `0, '', NaN, null, undefined, false`
  
- Важные моменты при работе с операторами сравнения:

  При нестрогом равенстве `==` undefined и null равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
	 ```md
	 null == undefined // true
  ```
  При строгом равенстве `===` эти значения различны, так как различны их типы.
  ```md
	 null === undefined // false
  ```
  Ссылочные типы данных не равны друг другу, т.к. это независимые друг от друга объекты/массивы с разными ссылками. Даже если у них абсолютно одинаковое 
  наполнение.
   ```JS
	 {}=={} // false
	 {}==={} //false
	 []==[] //false
	 []===[]// false
   ```

 - К чему приводятся null и undefined при использовании математических операторов и операторов сравнения.

   При работе с математическими операторами `null` приводится к `0`, а `undefined` к `NaN`.   
   Сравним `null` с нулём:
   ```JS
   alert( null > 0 );  // (1) false
   alert( null == 0 ); // (2) false
   alert( null >= 0 ); // (3) true
   ```

   С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений 
   выше должен быть true, но они оба ложны.

   Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому 
   выражение (3) null >= 0 истинно, а null > 0 ложно.

   С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и 
   не равны ничему другому. Поэтому (2) null == 0 ложно.

   Значение undefined несравнимо с другими значениями:
   ```JS
   alert( undefined > 0 ); // false (1)
   alert( undefined < 0 ); // false (2)
   alert( undefined == 0 ); // false (3)
   ```

   Почему же сравнение undefined с нулём всегда ложно?

   На это есть следующие причины:

   Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых 
   сравнениях.
   Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.

- Swich case конструкция, что это для чего что заменяет?

  Конструкция `switch` заменяет собой сразу несколько `if`.   
  Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
  Конструкция switch имеет один или более блок case и необязательный блок default.
  
- Обязателен ли default?

  Нет, блок `default` необязательный.
  
- Что такое тернарный оператор? Почему он называется тернарный?

  Тернарный или условный оператор используется в качестве сокращённого варианта инструкции `if...else`.   
  Синтаксис:
  ```JS
  let result = условие ? значение1 : значение2;
  ```
  Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.   
  Его называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.   
  
- Может ли мы создавать цепочку из тернарных операторов?

  Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.   
  Но это считается анти паттерном, т.к. ухудшает читаемость кода, поэтому не стоит создавать цепочку тернарных операторов.   

  
- Что такое оператор запятая?

  Оператор запятая полностью отличается от запятой в массивах, объектах, аргументах и параметрах функции.
  
- Что такое оператор расширения (разворота)? spread-оператор
- JS операторы spread vs rest

  Когда мы видим `...` в коде, это могут быть как остаточные параметры (rest), так и оператор расширения (spread).
  Как отличить их друг от друга:   
  Если `...` располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
  Если `...` встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.


## ПЕРЕМЕННЫЙ, ХОИСТИНГ

- как можно объявить переменную?
- что такое переменная?
- разница между let, var и const
- что такое хоистинг?
- какие функции всплывают?
- что будет если:
		 ```JS
		 console.log(a)
		 var a = 5;
		 ```
- а если var заменить на let что измениться?
- что такое временная мертвая зона и зачем она нужна?
- что такое полифиллы. Приведи пример.

## ФУНКЦИИ:

- что такое функциональное программирование
- какие виды функций ты знаешь. Какие различия
- какие особенности у стрелочной функции
- что такое callback функция
- что такое функция высшего порядка?
- что такое чистая функция?
- что такое iife? Зачем?
- что такое функция конструктор
- что такое замыкание
- что такое new?
- что такое this?
- можем ли мы привязаться this к функции? Какие методы?
- особенности bind
- что такое замыкание

## OOP

- что такое OOP
- что такое инкапсуляция
- что такое наследование
- что такое полиморфизм
- что такое композиция
- что такое агрегация
- что такое ассоциация
- что такое абстрактный класс
- что такое интерфейс
- что такое абстрактный метод
- что такое статический метод
- что такое статическое свойство
- что такое инстанс и инстанцирование
- что такое декоратор
- что такое декоратор класса
- что такое декоратор метода
- что такое декоратор свойства
- что такое декоратор параметра
- что такое декоратор геттера и сеттера
- что такое декоратор функции

## ОБЪЕКТЫ. МАССИВЫ.

- Создать объект через Object.create
- Что метод в себя принимает
- Как копировать объект. Глубоко и нет. Нюансы JSON.stringify.
- Перечисли встроенные методы объекта, для получения ключей, значений, и ещё один похожий метод.
- что такое map и set? Чем map отличается от объекта.
- Object.is что это для чего.
- дескрипторы свойств объекта. Врядли будет, но просто прочитать шо это.
- что такое массив, как создать, несколько способов, как копировать.
- Как копировать честь массива.
- Как сгладить вложенный массив
- разница map и forEach
- reduce что делает, что принимает вторым аргументом
- filter что делает
- какие методы изменяют исходный массив
- можем ли мы изменять массив и объект после объявления через const. Почему?

## ЦИКЛЫ

- перечислите все циклы
- for in для чего
- for of для чего
- можно ли применить for in для массива. Что будет?
- можно ли применить for of или while для объекта? Что будет?
- цикл do while что делает?
- break и continue просто помнить шо это

## БРAУЗЕР

- что такое DOM?
- что такое BOM?
- что такое CSSOM?
- что такое document
- поиск элементов в DOM(Не забывать про getElementsBy..)
- живые и неживые коллекции что это
- браузерные события. Знать основные, помнить что есть DOMContentLoaded
- фазы события, перечислить
- обработчик событий, как повесить, как убрать. Какой нюанс, если мы хотим удалить обработчик
- event.preventDefault() что это что делает
- как предотвратить распространение события
- что такое делегирования событий

## АСИНХРОННОСТЬ

- что такое синхронный код
- что такое асинхронный код
- что такое event loop
- что такое коллбеки
- что такое промисы
- что такое async await
- что такое микро и макро задачи

## ОБЩЕЕ

- что такое стек вызовов
- что такое очередь задач
- что такое мемоизация
- что такое рекурсия
- что такое чистая функция
- что такое побочный эффект
- что такое мутация
- что такое иммутабельность
- что такое декларативный код
- что такое императивный код
- что такое SOLID, DRY, KISS, YAGNI
- что такое TDD
- что такое BDD
- что такое DDD
- что такое Feature sliced design
- что такое MVC
- что такое MVVM
- что такое MVP
- что такое SPA
- что такое SSR
- что такое CSR
- что такое PWA
- что такое SSR
- что такое антипаттерны
- что такое рефакторинг
- что такое абстракция

## Ссылки

- дом https://docs.google.com/presentation/d/1rBIdCmdt_FmbynznNmzhYvvSJ3jGhnLV/edit?pli=1#slide=id.p1
- типы данных, переменные:  https://docs.google.com/presentation/d/1umua1fqaY87LzaYetfd8aTfOaH2SuApo/edit#slide=id.p2
- еще делились, спрашивали про
	Symbol.iterator https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator
